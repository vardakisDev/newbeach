{"ast":null,"code":"/**\n * Content Type instances\n * @namespace ContentType\n */\nimport cloneDeep from 'lodash/cloneDeep';\nimport { freezeSys, toPlainObject, createRequestConfig } from 'contentful-sdk-core';\nimport enhanceWithMethods from '../enhance-with-methods';\nimport { createUpdateEntity, createDeleteEntity, createPublishEntity, createUnpublishEntity, createPublishedChecker, createUpdatedChecker, createDraftChecker } from '../instance-actions';\nimport { wrapEditorInterface } from './editor-interface';\nimport errorHandler from '../error-handler';\nimport { wrapSnapshot, wrapSnapshotCollection } from './snapshot';\n/**\n * @memberof ContentType\n * @typedef ContentType\n * @prop {Meta.Sys} sys - System metadata\n * @prop {string} name\n * @prop {string} description\n * @prop {string} displayField - Field used as the main display field for Entries\n * @prop {Array<Field>} fields - All the fields contained in this Content Type\n * @prop {function(): Object} toPlainObject() - Returns this Content Type as a plain JS object\n */\n\nfunction createContentTypeApi(http) {\n  return {\n    /**\n     * Sends an update to the server with any changes made to the object's properties. <br />\n     * <strong>Important note about deleting fields</strong>: The standard way to delete a field is with two updates: first omit the property from your responses (set the field attribute \"omitted\" to true), and then\n     * delete it by setting the attribute \"deleted\" to true. See the \"Deleting fields\" section in the\n     * <a href=\"https://www.contentful.com/developers/docs/references/content-management-api/#/reference/content-types/content-type\">API reference</a> for more reasoning. Alternatively,\n     * you may use the convenience method omitAndDeleteField to do both steps at once.\n     * @memberof ContentType\n     * @func update\n     * @return {Promise<ContentType>} Object returned from the server with updated changes.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => {\n     *  contentType.name = 'New name'\n     *  return contentType.update()\n     * })\n     * .then(contentType => console.log(contentType))\n     * .catch(console.error)\n     */\n    update: createUpdateEntity({\n      http: http,\n      entityPath: 'content_types',\n      wrapperMethod: wrapContentType\n    }),\n\n    /**\n     * Deletes this object on the server.\n     * @memberof ContentType\n     * @func delete\n     * @return {Promise} Promise for the deletion. It contains no data, but the Promise error case should be handled.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => contentType.delete())\n     * .then(() => console.log('contentType deleted'))\n     * .catch(console.error)\n     */\n    delete: createDeleteEntity({\n      http: http,\n      entityPath: 'content_types'\n    }),\n\n    /**\n     * Publishes the object\n     * @memberof ContentType\n     * @func publish\n     * @return {Promise<ContentType>} Object returned from the server with updated metadata.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => contentType.publish())\n     * .then((contentType) => console.log(`${contentType.sys.id} is published`))\n     * .catch(console.error)\n     */\n    publish: createPublishEntity({\n      http: http,\n      entityPath: 'content_types',\n      wrapperMethod: wrapContentType\n    }),\n\n    /**\n     * Unpublishes the object\n     * @memberof ContentType\n     * @func unpublish\n     * @return {Promise<ContentType>} Object returned from the server with updated metadata.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => contentType.unpublish())\n     * .then((contentType) => console.log(`${contentType.sys.id} is unpublished`))\n     * .catch(console.error)\n     */\n    unpublish: createUnpublishEntity({\n      http: http,\n      entityPath: 'content_types',\n      wrapperMethod: wrapContentType\n    }),\n\n    /**\n     * Gets the editor interface for the object <br />\n     * <strong>Important note</strong>: The editor interface only represent a published contentType.<br />\n     * To get the most recent representation of the contentType make sure to publish it first\n     * @memberof ContentType\n     * @func getEditorInterface\n     * @return {Promise<EditorInterface.EditorInterface>} Object returned from the server with the current editor interface.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => contentType.getEditorInterface())\n     * .then((editorInterface) => console.log(editorInterface.contorls))\n     * .catch(console.error)\n     */\n    getEditorInterface: function getEditorInterface() {\n      return http.get('content_types/' + this.sys.id + '/editor_interface').then(function (response) {\n        return wrapEditorInterface(http, response.data);\n      }, errorHandler);\n    },\n\n    /**\n     * Gets all snapshots of a contentType\n     * @memberof ContentType\n     * @func getSnapshots\n     * @return Promise<Snapshot>\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((entry) => entry.getSnapshots())\n     * .then((snapshots) => console.log(snapshots.items))\n     * .catch(console.error)\n     */\n    getSnapshots: function getSnapshots() {\n      var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return http.get('content_types/' + this.sys.id + '/snapshots', createRequestConfig({\n        query: query\n      })).then(function (response) {\n        return wrapSnapshotCollection(http, response.data);\n      }, errorHandler);\n    },\n\n    /**\n     * Gets a snapshot of a contentType\n     * @memberof ContentType\n     * @func getSnapshot\n     * @param {string} snapshotId - Id of the snapshot\n     * @return Promise<Snapshot>\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<content_type-id>'))\n     * .then((entry) => entry.getSnapshot('<snapshot-id>'))\n     * .then((snapshot) => console.log(snapshot))\n     * .catch(console.error)\n     */\n    getSnapshot: function getSnapshot(snapshotId) {\n      return http.get('content_types/' + this.sys.id + '/snapshots/' + snapshotId).then(function (response) {\n        return wrapSnapshot(http, response.data);\n      }, errorHandler);\n    },\n\n    /**\n     * Checks if the contentType is published. A published contentType might have unpublished changes (@see {ContentType.isUpdated})\n     * @memberof ContentType\n     * @func isPublished\n     * @return {boolean}\n     */\n    isPublished: createPublishedChecker(),\n\n    /**\n     * Checks if the contentType is updated. This means the contentType was previously published but has unpublished changes.\n     * @memberof ContentType\n     * @func isUpdated\n     * @return {boolean}\n     */\n    isUpdated: createUpdatedChecker(),\n\n    /**\n     * Checks if the contentType is in draft mode. This means it is not published.\n     * @memberof ContentType\n     * @func isDraft\n     * @return {boolean}\n     */\n    isDraft: createDraftChecker(),\n\n    /**\n     * Omits and deletes a field if it exists on the contentType. This is a convenience method which does both operations at once and potentially less\n     * safe than the standard way. See note about deleting fields on the Update method.\n     * @memberof ContentType\n     * @func omitAndDeleteField\n     * @return {Promise<ContentType>} Object returned from the server with updated metadata.\n     */\n    omitAndDeleteField: function omitAndDeleteField(id) {\n      return this.findAndUpdateField(id, 'omitted', true).then(function (newContentType) {\n        return newContentType.findAndUpdateField(id, 'deleted', true);\n      }).catch(errorHandler);\n    },\n\n    /**\n     * @private\n     * @param {string} id - unique ID of the field\n     * @param {string} key - the attribute on the field to change\n     * @param {string} value - the value to set the attribute to\n     * @return {Promise<ContentType>}\n     */\n    findAndUpdateField: function findAndUpdateField(id, key, value) {\n      var field = this.fields.find(function (field) {\n        return field.id === id;\n      });\n\n      if (!field) {\n        return Promise.reject(new Error('Tried to omitAndDeleteField on a nonexistent field, ' + id + ', on the content type ' + this.name + '.'));\n      }\n\n      field[key] = value;\n      return this.update();\n    }\n  };\n}\n/**\n * @private\n * @param {Object} http - HTTP client instance\n * @param {Object} data - Raw content type data\n * @return {ContentType} Wrapped content type data\n */\n\n\nexport function wrapContentType(http, data) {\n  var contentType = toPlainObject(cloneDeep(data));\n  enhanceWithMethods(contentType, createContentTypeApi(http));\n  return freezeSys(contentType);\n}\n/**\n * @private\n * @param {Object} http - HTTP client instance\n * @param {Object} data - Raw content type collection data\n * @return {ContentTypeCollection} Wrapped content type collection data\n */\n\nexport function wrapContentTypeCollection(http, data) {\n  var contentTypes = toPlainObject(cloneDeep(data));\n  contentTypes.items = contentTypes.items.map(function (entity) {\n    return wrapContentType(http, entity);\n  });\n  return freezeSys(contentTypes);\n}","map":{"version":3,"sources":["C:/Users/στελης/Desktop/Hotel React/resort/node_modules/contentful-management/dist/es-modules/entities/content-type.js"],"names":["cloneDeep","freezeSys","toPlainObject","createRequestConfig","enhanceWithMethods","createUpdateEntity","createDeleteEntity","createPublishEntity","createUnpublishEntity","createPublishedChecker","createUpdatedChecker","createDraftChecker","wrapEditorInterface","errorHandler","wrapSnapshot","wrapSnapshotCollection","createContentTypeApi","http","update","entityPath","wrapperMethod","wrapContentType","delete","publish","unpublish","getEditorInterface","get","sys","id","then","response","data","getSnapshots","query","arguments","length","undefined","getSnapshot","snapshotId","isPublished","isUpdated","isDraft","omitAndDeleteField","findAndUpdateField","newContentType","catch","key","value","field","fields","find","Promise","reject","Error","name","contentType","wrapContentTypeCollection","contentTypes","items","map","entity"],"mappings":"AAAA;;;;AAKA,OAAOA,SAAP,MAAsB,kBAAtB;AACA,SAASC,SAAT,EAAoBC,aAApB,EAAmCC,mBAAnC,QAA8D,qBAA9D;AACA,OAAOC,kBAAP,MAA+B,yBAA/B;AACA,SAASC,kBAAT,EAA6BC,kBAA7B,EAAiDC,mBAAjD,EAAsEC,qBAAtE,EAA6FC,sBAA7F,EAAqHC,oBAArH,EAA2IC,kBAA3I,QAAqK,qBAArK;AACA,SAASC,mBAAT,QAAoC,oBAApC;AACA,OAAOC,YAAP,MAAyB,kBAAzB;AACA,SAASC,YAAT,EAAuBC,sBAAvB,QAAqD,YAArD;AACA;;;;;;;;;;;AAWA,SAASC,oBAAT,CAA8BC,IAA9B,EAAoC;AAClC,SAAO;AAEL;;;;;;;;;;;;;;;;;;;;;;;;;AAyBAC,IAAAA,MAAM,EAAEb,kBAAkB,CAAC;AACzBY,MAAAA,IAAI,EAAEA,IADmB;AAEzBE,MAAAA,UAAU,EAAE,eAFa;AAGzBC,MAAAA,aAAa,EAAEC;AAHU,KAAD,CA3BrB;;AAiCL;;;;;;;;;;;;;;;;;;AAkBAC,IAAAA,MAAM,EAAEhB,kBAAkB,CAAC;AACzBW,MAAAA,IAAI,EAAEA,IADmB;AAEzBE,MAAAA,UAAU,EAAE;AAFa,KAAD,CAnDrB;;AAwDL;;;;;;;;;;;;;;;;;;AAkBAI,IAAAA,OAAO,EAAEhB,mBAAmB,CAAC;AAC3BU,MAAAA,IAAI,EAAEA,IADqB;AAE3BE,MAAAA,UAAU,EAAE,eAFe;AAG3BC,MAAAA,aAAa,EAAEC;AAHY,KAAD,CA1EvB;;AAgFL;;;;;;;;;;;;;;;;;;AAkBAG,IAAAA,SAAS,EAAEhB,qBAAqB,CAAC;AAC/BS,MAAAA,IAAI,EAAEA,IADyB;AAE/BE,MAAAA,UAAU,EAAE,eAFmB;AAG/BC,MAAAA,aAAa,EAAEC;AAHgB,KAAD,CAlG3B;;AAwGL;;;;;;;;;;;;;;;;;;;;AAoBAI,IAAAA,kBAAkB,EAAE,SAASA,kBAAT,GAA8B;AAChD,aAAOR,IAAI,CAACS,GAAL,CAAS,mBAAmB,KAAKC,GAAL,CAASC,EAA5B,GAAiC,mBAA1C,EAA+DC,IAA/D,CAAoE,UAAUC,QAAV,EAAoB;AAC7F,eAAOlB,mBAAmB,CAACK,IAAD,EAAOa,QAAQ,CAACC,IAAhB,CAA1B;AACD,OAFM,EAEJlB,YAFI,CAAP;AAGD,KAhII;;AAkIL;;;;;;;;;;;;;;;;;;AAkBAmB,IAAAA,YAAY,EAAE,SAASA,YAAT,GAAwB;AACpC,UAAIC,KAAK,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;AAEA,aAAOjB,IAAI,CAACS,GAAL,CAAS,mBAAmB,KAAKC,GAAL,CAASC,EAA5B,GAAiC,YAA1C,EAAwDzB,mBAAmB,CAAC;AAAE8B,QAAAA,KAAK,EAAEA;AAAT,OAAD,CAA3E,EAA+FJ,IAA/F,CAAoG,UAAUC,QAAV,EAAoB;AAC7H,eAAOf,sBAAsB,CAACE,IAAD,EAAOa,QAAQ,CAACC,IAAhB,CAA7B;AACD,OAFM,EAEJlB,YAFI,CAAP;AAGD,KA1JI;;AA4JL;;;;;;;;;;;;;;;;;;;AAmBAwB,IAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBC,UAArB,EAAiC;AAC5C,aAAOrB,IAAI,CAACS,GAAL,CAAS,mBAAmB,KAAKC,GAAL,CAASC,EAA5B,GAAiC,aAAjC,GAAiDU,UAA1D,EAAsET,IAAtE,CAA2E,UAAUC,QAAV,EAAoB;AACpG,eAAOhB,YAAY,CAACG,IAAD,EAAOa,QAAQ,CAACC,IAAhB,CAAnB;AACD,OAFM,EAEJlB,YAFI,CAAP;AAGD,KAnLI;;AAoLL;;;;;;AAMA0B,IAAAA,WAAW,EAAE9B,sBAAsB,EA1L9B;;AA4LL;;;;;;AAMA+B,IAAAA,SAAS,EAAE9B,oBAAoB,EAlM1B;;AAoML;;;;;;AAMA+B,IAAAA,OAAO,EAAE9B,kBAAkB,EA1MtB;;AA4ML;;;;;;;AAOA+B,IAAAA,kBAAkB,EAAE,SAASA,kBAAT,CAA4Bd,EAA5B,EAAgC;AAClD,aAAO,KAAKe,kBAAL,CAAwBf,EAAxB,EAA4B,SAA5B,EAAuC,IAAvC,EAA6CC,IAA7C,CAAkD,UAAUe,cAAV,EAA0B;AACjF,eAAOA,cAAc,CAACD,kBAAf,CAAkCf,EAAlC,EAAsC,SAAtC,EAAiD,IAAjD,CAAP;AACD,OAFM,EAEJiB,KAFI,CAEEhC,YAFF,CAAP;AAGD,KAvNI;;AAyNL;;;;;;;AAOA8B,IAAAA,kBAAkB,EAAE,SAASA,kBAAT,CAA4Bf,EAA5B,EAAgCkB,GAAhC,EAAqCC,KAArC,EAA4C;AAC9D,UAAIC,KAAK,GAAG,KAAKC,MAAL,CAAYC,IAAZ,CAAiB,UAAUF,KAAV,EAAiB;AAC5C,eAAOA,KAAK,CAACpB,EAAN,KAAaA,EAApB;AACD,OAFW,CAAZ;;AAGA,UAAI,CAACoB,KAAL,EAAY;AACV,eAAOG,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,yDAAyDzB,EAAzD,GAA8D,wBAA9D,GAAyF,KAAK0B,IAA9F,GAAqG,GAA/G,CAAf,CAAP;AACD;;AACDN,MAAAA,KAAK,CAACF,GAAD,CAAL,GAAaC,KAAb;AACA,aAAO,KAAK7B,MAAL,EAAP;AACD;AAzOI,GAAP;AA2OD;AAED;;;;;;;;AAMA,OAAO,SAASG,eAAT,CAAyBJ,IAAzB,EAA+Bc,IAA/B,EAAqC;AAC1C,MAAIwB,WAAW,GAAGrD,aAAa,CAACF,SAAS,CAAC+B,IAAD,CAAV,CAA/B;AACA3B,EAAAA,kBAAkB,CAACmD,WAAD,EAAcvC,oBAAoB,CAACC,IAAD,CAAlC,CAAlB;AACA,SAAOhB,SAAS,CAACsD,WAAD,CAAhB;AACD;AAED;;;;;;;AAMA,OAAO,SAASC,yBAAT,CAAmCvC,IAAnC,EAAyCc,IAAzC,EAA+C;AACpD,MAAI0B,YAAY,GAAGvD,aAAa,CAACF,SAAS,CAAC+B,IAAD,CAAV,CAAhC;AACA0B,EAAAA,YAAY,CAACC,KAAb,GAAqBD,YAAY,CAACC,KAAb,CAAmBC,GAAnB,CAAuB,UAAUC,MAAV,EAAkB;AAC5D,WAAOvC,eAAe,CAACJ,IAAD,EAAO2C,MAAP,CAAtB;AACD,GAFoB,CAArB;AAGA,SAAO3D,SAAS,CAACwD,YAAD,CAAhB;AACD","sourcesContent":["/**\n * Content Type instances\n * @namespace ContentType\n */\n\nimport cloneDeep from 'lodash/cloneDeep';\nimport { freezeSys, toPlainObject, createRequestConfig } from 'contentful-sdk-core';\nimport enhanceWithMethods from '../enhance-with-methods';\nimport { createUpdateEntity, createDeleteEntity, createPublishEntity, createUnpublishEntity, createPublishedChecker, createUpdatedChecker, createDraftChecker } from '../instance-actions';\nimport { wrapEditorInterface } from './editor-interface';\nimport errorHandler from '../error-handler';\nimport { wrapSnapshot, wrapSnapshotCollection } from './snapshot';\n/**\n * @memberof ContentType\n * @typedef ContentType\n * @prop {Meta.Sys} sys - System metadata\n * @prop {string} name\n * @prop {string} description\n * @prop {string} displayField - Field used as the main display field for Entries\n * @prop {Array<Field>} fields - All the fields contained in this Content Type\n * @prop {function(): Object} toPlainObject() - Returns this Content Type as a plain JS object\n */\n\nfunction createContentTypeApi(http) {\n  return {\n\n    /**\n     * Sends an update to the server with any changes made to the object's properties. <br />\n     * <strong>Important note about deleting fields</strong>: The standard way to delete a field is with two updates: first omit the property from your responses (set the field attribute \"omitted\" to true), and then\n     * delete it by setting the attribute \"deleted\" to true. See the \"Deleting fields\" section in the\n     * <a href=\"https://www.contentful.com/developers/docs/references/content-management-api/#/reference/content-types/content-type\">API reference</a> for more reasoning. Alternatively,\n     * you may use the convenience method omitAndDeleteField to do both steps at once.\n     * @memberof ContentType\n     * @func update\n     * @return {Promise<ContentType>} Object returned from the server with updated changes.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => {\n     *  contentType.name = 'New name'\n     *  return contentType.update()\n     * })\n     * .then(contentType => console.log(contentType))\n     * .catch(console.error)\n     */\n    update: createUpdateEntity({\n      http: http,\n      entityPath: 'content_types',\n      wrapperMethod: wrapContentType\n    }),\n\n    /**\n     * Deletes this object on the server.\n     * @memberof ContentType\n     * @func delete\n     * @return {Promise} Promise for the deletion. It contains no data, but the Promise error case should be handled.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => contentType.delete())\n     * .then(() => console.log('contentType deleted'))\n     * .catch(console.error)\n     */\n    delete: createDeleteEntity({\n      http: http,\n      entityPath: 'content_types'\n    }),\n\n    /**\n     * Publishes the object\n     * @memberof ContentType\n     * @func publish\n     * @return {Promise<ContentType>} Object returned from the server with updated metadata.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => contentType.publish())\n     * .then((contentType) => console.log(`${contentType.sys.id} is published`))\n     * .catch(console.error)\n     */\n    publish: createPublishEntity({\n      http: http,\n      entityPath: 'content_types',\n      wrapperMethod: wrapContentType\n    }),\n\n    /**\n     * Unpublishes the object\n     * @memberof ContentType\n     * @func unpublish\n     * @return {Promise<ContentType>} Object returned from the server with updated metadata.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => contentType.unpublish())\n     * .then((contentType) => console.log(`${contentType.sys.id} is unpublished`))\n     * .catch(console.error)\n     */\n    unpublish: createUnpublishEntity({\n      http: http,\n      entityPath: 'content_types',\n      wrapperMethod: wrapContentType\n    }),\n\n    /**\n     * Gets the editor interface for the object <br />\n     * <strong>Important note</strong>: The editor interface only represent a published contentType.<br />\n     * To get the most recent representation of the contentType make sure to publish it first\n     * @memberof ContentType\n     * @func getEditorInterface\n     * @return {Promise<EditorInterface.EditorInterface>} Object returned from the server with the current editor interface.\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((contentType) => contentType.getEditorInterface())\n     * .then((editorInterface) => console.log(editorInterface.contorls))\n     * .catch(console.error)\n     */\n    getEditorInterface: function getEditorInterface() {\n      return http.get('content_types/' + this.sys.id + '/editor_interface').then(function (response) {\n        return wrapEditorInterface(http, response.data);\n      }, errorHandler);\n    },\n\n    /**\n     * Gets all snapshots of a contentType\n     * @memberof ContentType\n     * @func getSnapshots\n     * @return Promise<Snapshot>\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<contentType_id>'))\n     * .then((entry) => entry.getSnapshots())\n     * .then((snapshots) => console.log(snapshots.items))\n     * .catch(console.error)\n     */\n    getSnapshots: function getSnapshots() {\n      var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      return http.get('content_types/' + this.sys.id + '/snapshots', createRequestConfig({ query: query })).then(function (response) {\n        return wrapSnapshotCollection(http, response.data);\n      }, errorHandler);\n    },\n\n    /**\n     * Gets a snapshot of a contentType\n     * @memberof ContentType\n     * @func getSnapshot\n     * @param {string} snapshotId - Id of the snapshot\n     * @return Promise<Snapshot>\n     * @example\n     * const contentful = require('contentful-management')\n     *\n     * const client = contentful.createClient({\n     *   accessToken: '<content_management_api_key>'\n     * })\n     *\n     * client.getSpace('<space_id>')\n     * .then((space) => space.getContentType('<content_type-id>'))\n     * .then((entry) => entry.getSnapshot('<snapshot-id>'))\n     * .then((snapshot) => console.log(snapshot))\n     * .catch(console.error)\n     */\n    getSnapshot: function getSnapshot(snapshotId) {\n      return http.get('content_types/' + this.sys.id + '/snapshots/' + snapshotId).then(function (response) {\n        return wrapSnapshot(http, response.data);\n      }, errorHandler);\n    },\n    /**\n     * Checks if the contentType is published. A published contentType might have unpublished changes (@see {ContentType.isUpdated})\n     * @memberof ContentType\n     * @func isPublished\n     * @return {boolean}\n     */\n    isPublished: createPublishedChecker(),\n\n    /**\n     * Checks if the contentType is updated. This means the contentType was previously published but has unpublished changes.\n     * @memberof ContentType\n     * @func isUpdated\n     * @return {boolean}\n     */\n    isUpdated: createUpdatedChecker(),\n\n    /**\n     * Checks if the contentType is in draft mode. This means it is not published.\n     * @memberof ContentType\n     * @func isDraft\n     * @return {boolean}\n     */\n    isDraft: createDraftChecker(),\n\n    /**\n     * Omits and deletes a field if it exists on the contentType. This is a convenience method which does both operations at once and potentially less\n     * safe than the standard way. See note about deleting fields on the Update method.\n     * @memberof ContentType\n     * @func omitAndDeleteField\n     * @return {Promise<ContentType>} Object returned from the server with updated metadata.\n     */\n    omitAndDeleteField: function omitAndDeleteField(id) {\n      return this.findAndUpdateField(id, 'omitted', true).then(function (newContentType) {\n        return newContentType.findAndUpdateField(id, 'deleted', true);\n      }).catch(errorHandler);\n    },\n\n    /**\n     * @private\n     * @param {string} id - unique ID of the field\n     * @param {string} key - the attribute on the field to change\n     * @param {string} value - the value to set the attribute to\n     * @return {Promise<ContentType>}\n     */\n    findAndUpdateField: function findAndUpdateField(id, key, value) {\n      var field = this.fields.find(function (field) {\n        return field.id === id;\n      });\n      if (!field) {\n        return Promise.reject(new Error('Tried to omitAndDeleteField on a nonexistent field, ' + id + ', on the content type ' + this.name + '.'));\n      }\n      field[key] = value;\n      return this.update();\n    }\n  };\n}\n\n/**\n * @private\n * @param {Object} http - HTTP client instance\n * @param {Object} data - Raw content type data\n * @return {ContentType} Wrapped content type data\n */\nexport function wrapContentType(http, data) {\n  var contentType = toPlainObject(cloneDeep(data));\n  enhanceWithMethods(contentType, createContentTypeApi(http));\n  return freezeSys(contentType);\n}\n\n/**\n * @private\n * @param {Object} http - HTTP client instance\n * @param {Object} data - Raw content type collection data\n * @return {ContentTypeCollection} Wrapped content type collection data\n */\nexport function wrapContentTypeCollection(http, data) {\n  var contentTypes = toPlainObject(cloneDeep(data));\n  contentTypes.items = contentTypes.items.map(function (entity) {\n    return wrapContentType(http, entity);\n  });\n  return freezeSys(contentTypes);\n}"]},"metadata":{},"sourceType":"module"}